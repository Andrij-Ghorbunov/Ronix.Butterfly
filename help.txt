Додаткові відомості про C# (окрім того, що було в відео):

одинарне = — це присвоєння, а порівняння, як ви могли помітити — подвійне: ==
оператор ==, як і інші типи порівняння (<, >, <=, >=, != — не дорівнює) повертає значення типу bool, тобто логічне (true або false). Саме таке значення і має йти після if, причому обов’язково в дужках.
Змінні типу bool можна обробляти відповідними операторами: !a — не a; a || b — a або b; a && b — а і b.
В циклах можуть використовуватись ключові слова break і continue. Break вивалюється з циклу взагалі, а continue — пропускає конкретно цю ітерацію (все до кінця циклу) і йде на наступну ітерацію (якщо вона є).
Флупівський цикл в C# пишеться так:
while (умова)
{
...
}
або так:
do
{
...
}
while (умова);
(Перший виконається тільки якщо умова на старті правдива, а другий один раз виконається обов’язково, а тоді вже буде перевіряти умову, щоб знати, чи йти на наступну ітерацію.)

Конструкцію using var x = ... сприймайте просто як var x = ... Відрізняється вона тільки тим, що гарантує, що як тільки закінчиться контекст видимості змінної x (тобто вона стане недоступною і непотрібною), над нею треба виконати спеціальну операцію .Dispose(), яка звільнить зайняті нею ресурси. Це робиться для того, щоб ваша програма не тримала відкритими, наприклад, файли на диску, якими ви покористувалися.

———————————————————————————————-

і ще про Nullable.

все те, що ми описуємо як class і створюємо як new(...) — це референсні типи даних. Іншими словами, в myCar не зберігається прямо всередині назва моделі автомобіля; натомість це просто вказівник на місце в т. зв. купі (heap), тобто  спеціальній області пам’яті, де починається власне вміст нашого myCar. Масиви — теж референсний тип даних.

На противагу цьому, замість слова class можна написати слово struct і отримати значеннєвий (нереференсний) тип даних, тобто такий, який прямо в собі тримає всі свої поля. int, bool, double — значеннєві типи. Цікавий значеннєвий тип — DateTime, тобто точка в часі; номер року, місяця, дня і так до мікросекунди — це буквально частини самого значення змінної типу DateTime, вони не лежать десь там в купі.

Одним з наслідків такого розділення є те, що в референсний тип можна покласти значення null, тобто «відсутній об’єкт». Це значення позначає, що в heap’і нашого об’єкта не існує взагалі. А от в int не можна покласти null: int x = null видасть помилку компілятора.

Однак деколи нам треба такий int, що він може бути null. Наприклад, розмір блоків, на які ми розбиваємо тренувальний датасет, або null, якщо не розбиваємо. Тоді нам потрібен тип Nullable<int>, або скорочено — int? . Це все ще значеннєвий тип, але він може набувати значення null, у нього є булівське поле HasValue, і якщо воно true, то можна витягти з нього власне int через поле Value.

——————————————————————————————-

а, ось ще забув: це ?: — тернарний оператор. Це таке як if, але в один рядок. Вираз a ? b : c, де a має тип bool, а b і c — довільний, але однаковий тип, означає «якщо a == true, то b, а якщо a == false, то c»

і ще ?? — це null coalescence operator. a ?? b означає «a, але якщо a == null, то b»